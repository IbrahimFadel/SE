use std::mem::transmute;

use cstree::{RawSyntaxKind, Syntax};
use flux_lexer::TokenKind;

#[derive(Debug, Copy, Clone, PartialEq, Hash, Eq, PartialOrd, Ord)]
#[repr(u32)]
pub enum SyntaxKind {
    Root,

    Visibility,
    FnDecl,
    FnReturnType,
    TypeDeclList,
    TypeDecl,
    TraitDecl,
    TraitAssocTypeDecl,
    TraitMethodDecl,
    ApplyDecl,
    ApplyDeclType,
    ApplyDeclTrait,
    ApplyDeclMethodList,
    ApplyDeclMethod,
    ApplyDeclAssocType,
    UseDecl,
    ModDecl,

    GenericParamList,
    TypeParam,
    WhereClause,
    WherePredicate,
    TypeBoundList,
    TypeBound,
    GenericArgList,
    Path,
    ArgList,
    ParamList,
    Param,

    CastExpr,
    BinExpr,
    IntExpr,
    FloatExpr,
    StringExpr,
    BlockExpr,
    AddressExpr,
    DerefExpr,
    CallExpr,
    IdxExpr,
    TupleExpr,
    ParenExpr,
    StructExpr,
    StructExprFieldList,
    StructExprField,
    PathExpr,
    MemberAccessExpr,
    IfExpr,
    ElseIfBlock,
    ElseBlock,
    IntrinsicExpr,

    ExprStmt,
    TerminatorExprStmt,

    TupleType,
    PathType,
    StructDecl,
    StructDeclFieldList,
    StructDeclField,
    EnumDecl,
    EnumDeclVariant,
    ArrayType,
    PtrType,
    ThisPathType,

    Whitespace,
    Comment,
    Mod,
    Use,
    Pub,
    Fn,
    Type,
    Apply,
    To,
    Where,
    Is,
    Mut,
    If,
    Else,
    Struct,
    Trait,
    Let,
    Return,
    Ident,
    IntLit,
    FloatLit,
    StringLit,
    This,

    Comma,
    CmpEq,
    CmpNeq,
    CmpLt,
    CmpGt,
    CmpLte,
    CmpGte,
    CmpAnd,
    CmpOr,
    Colon,
    DoubleColon,
    Plus,
    Minus,
    Star,
    Slash,
    Arrow,
    FatArrow,
    LParen,
    RParen,
    LBrace,
    RBrace,
    Eq,
    SemiColon,
    Intrinsic,
    Ampersand,
    Period,
    LSquare,
    RSquare,
    For,
    In,
    Enum,
    As,
    Name,
    Poisoned,
    LetStmt,
    EOF,
    Error,
}

pub type Flux = SyntaxKind;

impl Syntax for Flux {
    fn from_raw(raw: cstree::prelude::RawSyntaxKind) -> Self {
        unsafe { transmute(raw.0) }
        // match raw.0 {
        //     0 => ,
        //     n => panic!("Unknown raw syntax kind: {n}"),
        // }
    }

    fn into_raw(self) -> cstree::prelude::RawSyntaxKind {
        RawSyntaxKind(self as u32)
    }

    fn static_text(self) -> Option<&'static str> {
        match self {
            SyntaxKind::Mod => Some("mod"),
            SyntaxKind::Use => Some("use"),
            SyntaxKind::Pub => Some("pub"),
            SyntaxKind::Fn => Some("fn"),
            SyntaxKind::Apply => Some("apply"),
            SyntaxKind::To => Some("to"),
            SyntaxKind::Where => Some("where"),
            SyntaxKind::Is => Some("is"),
            SyntaxKind::Mut => Some("mut"),
            SyntaxKind::If => Some("if"),
            SyntaxKind::Else => Some("else"),
            SyntaxKind::Struct => Some("struct"),
            SyntaxKind::Trait => Some("trait"),
            SyntaxKind::Let => Some("let"),
            SyntaxKind::Return => Some("return"),
            SyntaxKind::This => Some("this"),
            SyntaxKind::Comma => Some(","),
            SyntaxKind::CmpEq => Some("=="),
            SyntaxKind::CmpNeq => Some("!="),
            SyntaxKind::CmpLt => Some("<"),
            SyntaxKind::CmpGt => Some(">"),
            SyntaxKind::CmpLte => Some("<="),
            SyntaxKind::CmpGte => Some(">="),
            SyntaxKind::CmpAnd => Some("&&"),
            SyntaxKind::CmpOr => Some("||"),
            SyntaxKind::Colon => Some(":"),
            SyntaxKind::DoubleColon => Some("::"),
            SyntaxKind::Plus => Some("+"),
            SyntaxKind::Minus => Some("-"),
            SyntaxKind::Star => Some("*"),
            SyntaxKind::Slash => Some("/"),
            SyntaxKind::Arrow => Some("->"),
            SyntaxKind::FatArrow => Some("=>"),
            SyntaxKind::LParen => Some("("),
            SyntaxKind::RParen => Some(")"),
            SyntaxKind::LBrace => Some("{"),
            SyntaxKind::RBrace => Some("}"),
            SyntaxKind::Eq => Some("="),
            SyntaxKind::SemiColon => Some(";"),
            SyntaxKind::Ampersand => Some("&"),
            SyntaxKind::Period => Some("."),
            SyntaxKind::LSquare => Some("["),
            SyntaxKind::RSquare => Some("]"),
            SyntaxKind::For => Some("for"),
            SyntaxKind::In => Some("in"),
            SyntaxKind::Enum => Some("enum"),
            SyntaxKind::As => Some("as"),
            _ => None,
        }
    }
}

pub type SyntaxToken = cstree::prelude::SyntaxToken<Flux>;
pub type SyntaxNode = cstree::prelude::SyntaxNode<Flux>;

impl From<TokenKind> for SyntaxKind {
    fn from(token_kind: TokenKind) -> Self {
        match token_kind {
            TokenKind::Whitespace => SyntaxKind::Whitespace,
            TokenKind::Comment => SyntaxKind::Comment,
            TokenKind::Ident => SyntaxKind::Ident,
            TokenKind::IntLit => SyntaxKind::IntLit,
            TokenKind::FloatLit => SyntaxKind::FloatLit,
            TokenKind::Mod => SyntaxKind::Mod,
            TokenKind::Use => SyntaxKind::Use,
            TokenKind::Pub => SyntaxKind::Pub,
            TokenKind::Fn => SyntaxKind::Fn,
            TokenKind::Type => SyntaxKind::Type,
            TokenKind::Apply => SyntaxKind::Apply,
            TokenKind::To => SyntaxKind::To,
            TokenKind::Where => SyntaxKind::Where,
            TokenKind::Is => SyntaxKind::Is,
            TokenKind::Mut => SyntaxKind::Mut,
            TokenKind::If => SyntaxKind::If,
            TokenKind::Else => SyntaxKind::Else,
            TokenKind::Struct => SyntaxKind::Struct,
            TokenKind::Trait => SyntaxKind::Trait,
            TokenKind::Let => SyntaxKind::Let,
            TokenKind::As => SyntaxKind::As,
            TokenKind::Return => SyntaxKind::Return,
            TokenKind::Comma => SyntaxKind::Comma,
            TokenKind::CmpEq => SyntaxKind::CmpEq,
            TokenKind::CmpNeq => SyntaxKind::CmpNeq,
            TokenKind::CmpLt => SyntaxKind::CmpLt,
            TokenKind::CmpGt => SyntaxKind::CmpGt,
            TokenKind::CmpLte => SyntaxKind::CmpLte,
            TokenKind::CmpGte => SyntaxKind::CmpGte,
            TokenKind::Colon => SyntaxKind::Colon,
            TokenKind::DoubleColon => SyntaxKind::DoubleColon,
            TokenKind::Plus => SyntaxKind::Plus,
            TokenKind::Minus => SyntaxKind::Minus,
            TokenKind::Star => SyntaxKind::Star,
            TokenKind::Slash => SyntaxKind::Slash,
            TokenKind::Arrow => SyntaxKind::Arrow,
            TokenKind::FatArrow => SyntaxKind::FatArrow,
            TokenKind::LParen => SyntaxKind::LParen,
            TokenKind::RParen => SyntaxKind::RParen,
            TokenKind::LBrace => SyntaxKind::LBrace,
            TokenKind::RBrace => SyntaxKind::RBrace,
            TokenKind::Eq => SyntaxKind::Eq,
            TokenKind::SemiColon => SyntaxKind::SemiColon,
            TokenKind::Intrinsic => SyntaxKind::Intrinsic,
            TokenKind::Ampersand => SyntaxKind::Ampersand,
            TokenKind::Period => SyntaxKind::Period,
            TokenKind::LSquare => SyntaxKind::LSquare,
            TokenKind::RSquare => SyntaxKind::RSquare,
            TokenKind::For => SyntaxKind::For,
            TokenKind::In => SyntaxKind::In,
            TokenKind::Enum => SyntaxKind::Enum,
            TokenKind::StringLit => SyntaxKind::StringLit,
            TokenKind::This => SyntaxKind::This,
            TokenKind::CmpAnd => SyntaxKind::CmpAnd,
            TokenKind::CmpOr => SyntaxKind::CmpOr,
            TokenKind::EOF => SyntaxKind::EOF,
        }
    }
}
