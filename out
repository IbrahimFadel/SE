#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod check {
    use flux_diagnostics::{Diagnostic, ToDiagnostic};
    use flux_span::{FileId, FileSpanned, InFile, Span, WithSpan};
    use itertools::Itertools;
    use lasso::{Spur, ThreadedRodeo};
    use crate::{
        diagnostics::TypeError, env::TraitRestriction,
        trait_solver::{TraitImplementation, TraitImplementationTable},
        ConcreteKind, TEnv, Type, TypeId, TypeKind,
    };
    mod traits {
        use super::*;
        impl TChecker {
            pub fn add_trait_to_context(&mut self, trait_name: Spur) {
                self.trait_implementation_table
                    .table
                    .insert(trait_name, ::alloc::vec::Vec::new());
            }
            fn get_trait_implementation_span(
                &mut self,
                trt: &Spur,
                implementation: &TraitImplementation,
            ) -> InFile<Span> {
                let impltrs = self
                    .trait_implementation_table
                    .spans
                    .get(trt)
                    .unwrap_or_else(|| flux_diagnostics::ice(
                        "span isn't stored for trait implementation",
                    ))
                    .clone();
                for (implementation_b, span) in impltrs {
                    if self
                        .are_trait_implementations_equal(
                            implementation,
                            &implementation_b,
                        )
                    {
                        return span;
                    }
                }
                flux_diagnostics::ice("span not stored for trait implementation");
            }
            pub fn add_trait_application_to_context(
                &mut self,
                trait_name: &FileSpanned<Spur>,
                trait_args: &[TypeId],
                impltor: TypeId,
            ) -> Result<(), Diagnostic> {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event compiler/flux_typesystem/src/check/traits.rs:36",
                                "flux_typesystem::check::traits",
                                ::tracing::Level::TRACE,
                                Some("compiler/flux_typesystem/src/check/traits.rs"),
                                Some(36u32),
                                Some("flux_typesystem::check::traits"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(
                                                &::core::fmt::Arguments::new_v1(
                                                    &["adding trait application ", "", " to ", " to context"],
                                                    &match (
                                                        &self.string_interner.resolve(&trait_name),
                                                        &if trait_args.is_empty() {
                                                            "".to_string()
                                                        } else {
                                                            {
                                                                let res = ::alloc::fmt::format(
                                                                    ::core::fmt::Arguments::new_v1(
                                                                        &["<", ">"],
                                                                        &[
                                                                            ::core::fmt::ArgumentV1::new_display(
                                                                                &trait_args
                                                                                    .iter()
                                                                                    .map(|arg| self.tenv.fmt_ty_id(*arg))
                                                                                    .join(", "),
                                                                            ),
                                                                        ],
                                                                    ),
                                                                );
                                                                res
                                                            }
                                                        },
                                                        &self.tenv.fmt_ty_id(impltor),
                                                    ) {
                                                        args => {
                                                            [
                                                                ::core::fmt::ArgumentV1::new_display(args.0),
                                                                ::core::fmt::ArgumentV1::new_display(args.1),
                                                                ::core::fmt::ArgumentV1::new_display(args.2),
                                                            ]
                                                        }
                                                    },
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let trait_implementors = self
                    .trait_implementation_table
                    .table
                    .get(trait_name)
                    .ok_or_else(|| {
                        TypeError::TraitDoesNotExist {
                            trait_name: self
                                .string_interner
                                .resolve(&trait_name)
                                .to_string(),
                            trait_name_file_span: trait_name.to_filespan(),
                        }
                            .to_diagnostic()
                    })?
                    .clone();
                let impltor_name = self
                    .tenv
                    .string_interner
                    .get_or_intern(&self.tenv.fmt_ty_id_constr(impltor));
                let implementations_for_trait_by_impltr: Vec<_> = trait_implementors
                    .iter()
                    .filter(|implementor| {
                        self.unify(
                                implementor.get_impltor(),
                                impltor,
                                Span::poisoned().in_file(FileId::poisoned()),
                            )
                            .is_ok()
                    })
                    .collect();
                let impltor_filespan = self.tenv.get_type_filespan(impltor);
                let impltor_arg_typekinds = self
                    .tenv
                    .get_entry(impltor)
                    .get_params()
                    .map(|typekinds| typekinds.to_vec())
                    .unwrap_or(::alloc::vec::Vec::new());
                let impltor_args = impltor_arg_typekinds
                    .iter()
                    .map(|kind| {
                        let ty = Type::new(kind.clone());
                        self.tenv
                            .insert(
                                ty
                                    .file_span(impltor_filespan.file_id, impltor_filespan.inner),
                            )
                    })
                    .collect();
                let trait_implementation = TraitImplementation::new(
                    trait_args.to_vec(),
                    impltor,
                    impltor_args,
                );
                for implementation in &implementations_for_trait_by_impltr {
                    if self
                        .are_trait_implementations_equal(
                            implementation,
                            &trait_implementation,
                        )
                    {
                        let implementation_a_span = self
                            .get_trait_implementation_span(trait_name, implementation);
                        return Err(
                            TypeError::ConflictingTraitImplementations {
                                trait_name: self
                                    .tenv
                                    .string_interner
                                    .resolve(&trait_name.inner.inner)
                                    .to_string(),
                                impltor: self
                                    .tenv
                                    .string_interner
                                    .resolve(&impltor_name)
                                    .to_string(),
                                implementation_a: (),
                                implementation_a_file_span: implementation_a_span,
                                implementation_b: (),
                                implementation_b_file_span: trait_name.to_filespan(),
                            }
                                .to_diagnostic(),
                        );
                    }
                }
                self.trait_implementation_table
                    .set_type_span(
                        trait_name.inner.inner,
                        trait_implementation.clone(),
                        trait_name.to_filespan(),
                    );
                let trait_implementors = self
                    .trait_implementation_table
                    .table
                    .get_mut(trait_name)
                    .unwrap();
                trait_implementors.push(trait_implementation);
                Ok(())
            }
            fn are_trait_implementations_equal(
                &mut self,
                impl_a: &TraitImplementation,
                impl_b: &TraitImplementation,
            ) -> bool {
                if impl_a.get_trait_params().len() != impl_b.get_trait_params().len() {
                    return false;
                }
                if impl_a.get_impltor_params().len() != impl_b.get_impltor_params().len()
                {
                    return false;
                }
                if self
                    .unify(
                        impl_a.get_impltor(),
                        impl_b.get_impltor(),
                        Span::poisoned().in_file(FileId::poisoned()),
                    )
                    .is_err()
                {
                    return false;
                }
                let num_ok_unifications = impl_a
                    .get_trait_params()
                    .iter()
                    .zip(impl_b.get_trait_params().iter())
                    .filter_map(|(a, b)| {
                        self.unify(*a, *b, Span::poisoned().in_file(FileId::poisoned()))
                            .ok()
                    })
                    .count();
                let trait_params_equal = num_ok_unifications
                    == impl_a.get_trait_params().len();
                let num_ok_unifications = impl_a
                    .get_impltor_params()
                    .iter()
                    .zip(impl_b.get_impltor_params().iter())
                    .filter_map(|(a, b)| {
                        self.unify(*a, *b, Span::poisoned().in_file(FileId::poisoned()))
                            .ok()
                    })
                    .count();
                let impltor_params_equal = num_ok_unifications
                    == impl_a.get_impltor_params().len();
                trait_params_equal && impltor_params_equal
            }
            fn are_trait_restrictions_equal(
                &mut self,
                a: &TraitRestriction,
                b: &TraitRestriction,
            ) -> bool {
                if a.name.inner.inner != b.name.inner.inner {
                    return false;
                }
                if a.args.len() != b.args.len() {
                    return false;
                }
                if a
                    .args
                    .iter()
                    .zip(b.args.iter())
                    .filter(|(a, b)| {
                        self.unify(
                                **a,
                                **b,
                                Span::poisoned().in_file(FileId::poisoned()),
                            )
                            .is_ok()
                    })
                    .count() != a.args.len()
                {
                    return false;
                }
                true
            }
            fn get_implementations(
                &mut self,
                trt: &FileSpanned<Spur>,
                impltor: TypeId,
            ) -> Result<Vec<TraitImplementation>, Diagnostic> {
                let impls = self
                    .trait_implementation_table
                    .table
                    .get(trt)
                    .ok_or_else(|| {
                        TypeError::TraitDoesNotExist {
                            trait_name: self.string_interner.resolve(&trt).to_string(),
                            trait_name_file_span: trt.to_filespan(),
                        }
                            .to_diagnostic()
                    })?
                    .clone();
                let impls = impls
                    .iter()
                    .filter(|implementation| {
                        self.unify(
                                impltor,
                                implementation.get_impltor(),
                                Span::poisoned().in_file(FileId::poisoned()),
                            )
                            .is_ok()
                    })
                    .cloned()
                    .collect();
                Ok(impls)
            }
            pub fn check_if_type_implements_restrictions(
                &mut self,
                ty: TypeId,
                restrictions: &[TraitRestriction],
            ) -> Result<(), Diagnostic> {
                let impltr_filespan = self.tenv.get_type_filespan(ty);
                let mut unimplemented_restrictions = ::alloc::vec::Vec::new();
                let kind = self.tenv.get_typekind_with_id(ty);
                match &kind.inner.inner {
                    TypeKind::Generic(_, restrictions_of_type_being_checked) => {
                        if restrictions_of_type_being_checked.len() != restrictions.len()
                        {
                            return Err(
                                TypeError::TraitRestrictionsNotMet {
                                    ty: self.tenv.fmt_ty_id(ty),
                                    ty_file_span: impltr_filespan,
                                    unmet_restrictions: unimplemented_restrictions,
                                }
                                    .to_diagnostic(),
                            );
                        }
                        if restrictions_of_type_being_checked
                            .iter()
                            .zip(restrictions.iter())
                            .filter(|(a, b)| self.are_trait_restrictions_equal(a, b))
                            .count() == restrictions.len()
                        {
                            return Ok(());
                        }
                    }
                    TypeKind::Int(depends_on) => {
                        if let Some(depends_on) = depends_on {
                            return self
                                .check_if_type_implements_restrictions(
                                    *depends_on,
                                    restrictions,
                                );
                        } else {
                            self.check_if_int_implements_restrictions(
                                kind.to_filespan(),
                                restrictions,
                            )?;
                        }
                    }
                    _ => {}
                }
                for restriction in restrictions {
                    if !self.does_type_implements_restrictions(ty, restriction)? {
                        unimplemented_restrictions
                            .push(
                                self
                                    .tenv
                                    .fmt_trait_restriction(restriction)
                                    .file_span(restriction.name.file_id, restriction.name.span),
                            );
                    }
                }
                if !unimplemented_restrictions.is_empty() {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event compiler/flux_typesystem/src/check/traits.rs:294",
                                    "flux_typesystem::check::traits",
                                    ::tracing::Level::INFO,
                                    Some("compiler/flux_typesystem/src/check/traits.rs"),
                                    Some(294u32),
                                    Some("flux_typesystem::check::traits"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &::core::fmt::Arguments::new_v1(
                                                        &["type `", "` does not implement restrictions: "],
                                                        &match (
                                                            &self.tenv.fmt_ty_id(ty),
                                                            &unimplemented_restrictions
                                                                .iter()
                                                                .map(|restriction| {
                                                                    let res = ::alloc::fmt::format(
                                                                        ::core::fmt::Arguments::new_v1(
                                                                            &["`", "`"],
                                                                            &[
                                                                                ::core::fmt::ArgumentV1::new_display(
                                                                                    &restriction.inner.inner,
                                                                                ),
                                                                            ],
                                                                        ),
                                                                    );
                                                                    res
                                                                })
                                                                .join(", "),
                                                        ) {
                                                            args => {
                                                                [
                                                                    ::core::fmt::ArgumentV1::new_display(args.0),
                                                                    ::core::fmt::ArgumentV1::new_display(args.1),
                                                                ]
                                                            }
                                                        },
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    Err(
                        TypeError::TraitRestrictionsNotMet {
                            ty: self.tenv.fmt_ty_id(ty),
                            ty_file_span: impltr_filespan,
                            unmet_restrictions: unimplemented_restrictions,
                        }
                            .to_diagnostic(),
                    )
                } else {
                    Ok(())
                }
            }
            fn does_type_implements_restrictions(
                &mut self,
                ty: TypeId,
                restriction: &TraitRestriction,
            ) -> Result<bool, Diagnostic> {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event compiler/flux_typesystem/src/check/traits.rs:318",
                                "flux_typesystem::check::traits",
                                ::tracing::Level::DEBUG,
                                Some("compiler/flux_typesystem/src/check/traits.rs"),
                                Some(318u32),
                                Some("flux_typesystem::check::traits"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(
                                                &::core::fmt::Arguments::new_v1(
                                                    &["checking if type `", "` implements restriction: "],
                                                    &match (
                                                        &self.tenv.fmt_ty_id(ty),
                                                        &{
                                                            let res = ::alloc::fmt::format(
                                                                ::core::fmt::Arguments::new_v1(
                                                                    &["`", "`"],
                                                                    &[
                                                                        ::core::fmt::ArgumentV1::new_display(
                                                                            &self.tenv.fmt_trait_restriction(restriction),
                                                                        ),
                                                                    ],
                                                                ),
                                                            );
                                                            res
                                                        },
                                                    ) {
                                                        args => {
                                                            [
                                                                ::core::fmt::ArgumentV1::new_display(args.0),
                                                                ::core::fmt::ArgumentV1::new_display(args.1),
                                                            ]
                                                        }
                                                    },
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let implementations_for_ty = self
                    .get_implementations(&restriction.name, ty)?
                    .to_vec();
                let mut found_valid_impl = false;
                for implementation in implementations_for_ty {
                    if implementation.get_trait_params().len() == restriction.args.len()
                    {
                        let num_ok_unifications = implementation
                            .get_trait_params()
                            .iter()
                            .zip(restriction.args.iter())
                            .filter_map(|(a, b)| {
                                self.unify(
                                        *a,
                                        *b,
                                        Span::poisoned().in_file(FileId::poisoned()),
                                    )
                                    .ok()
                            })
                            .count();
                        if num_ok_unifications == implementation.get_trait_params().len()
                        {
                            found_valid_impl = true;
                        }
                    }
                }
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event compiler/flux_typesystem/src/check/traits.rs:342",
                                "flux_typesystem::check::traits",
                                ::tracing::Level::DEBUG,
                                Some("compiler/flux_typesystem/src/check/traits.rs"),
                                Some(342u32),
                                Some("flux_typesystem::check::traits"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = CALLSITE.metadata().fields().iter();
                            CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                            Some(
                                                &::core::fmt::Arguments::new_v1(
                                                    &["type `", "`", " restrictions "],
                                                    &match (
                                                        &self.tenv.fmt_ty_id(ty),
                                                        &if found_valid_impl {
                                                            " implements".to_string()
                                                        } else {
                                                            {
                                                                let res = ::alloc::fmt::format(
                                                                    ::core::fmt::Arguments::new_v1(
                                                                        &[" does not implement"],
                                                                        &[],
                                                                    ),
                                                                );
                                                                res
                                                            }
                                                        },
                                                        &self.tenv.fmt_trait_restriction(restriction),
                                                    ) {
                                                        args => {
                                                            [
                                                                ::core::fmt::ArgumentV1::new_display(args.0),
                                                                ::core::fmt::ArgumentV1::new_display(args.1),
                                                                ::core::fmt::ArgumentV1::new_display(args.2),
                                                            ]
                                                        }
                                                    },
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                Ok(found_valid_impl)
            }
            fn check_if_int_implements_restrictions(
                &mut self,
                file_span: InFile<Span>,
                restrictions: &[TraitRestriction],
            ) -> Result<(), Diagnostic> {
                let s64 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("s64"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let s32 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("s32"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let s16 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("s16"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let s8 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("s8"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let u64 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("u64"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let u32 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("u32"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let u16 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("u16"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let u8 = self
                    .tenv
                    .insert(
                        Type::new(
                                TypeKind::Concrete(
                                    ConcreteKind::Path(
                                        self.string_interner.get_or_intern_static("u8"),
                                    ),
                                ),
                            )
                            .file_span(file_span.file_id, file_span.inner),
                    );
                let mut unmet_restrictions = ::alloc::vec::Vec::new();
                for restriction in restrictions {
                    let does_s64_impl = self
                        .does_type_implements_restrictions(s64, restriction)?;
                    let does_s32_impl = self
                        .does_type_implements_restrictions(s32, restriction)?;
                    let does_s16_impl = self
                        .does_type_implements_restrictions(s16, restriction)?;
                    let does_s8_impl = self
                        .does_type_implements_restrictions(s8, restriction)?;
                    let does_u64_impl = self
                        .does_type_implements_restrictions(u64, restriction)?;
                    let does_u32_impl = self
                        .does_type_implements_restrictions(u32, restriction)?;
                    let does_u16_impl = self
                        .does_type_implements_restrictions(u16, restriction)?;
                    let does_u8_impl = self
                        .does_type_implements_restrictions(u8, restriction)?;
                    let impltors: Vec<_> = [
                        (does_s64_impl, s64),
                        (does_s32_impl, s32),
                        (does_s16_impl, s16),
                        (does_s8_impl, s8),
                        (does_u64_impl, u64),
                        (does_u32_impl, u32),
                        (does_u16_impl, u16),
                        (does_u8_impl, u8),
                    ]
                        .into_iter()
                        .filter(|(b, _)| *b)
                        .map(|(_, id)| self.tenv.fmt_ty_id(id))
                        .collect();
                    {
                        ::std::io::_print(
                            ::core::fmt::Arguments::new_v1(
                                &["", " ", " ", " ", " ", " ", " ", " ", "\n"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(&does_s64_impl),
                                    ::core::fmt::ArgumentV1::new_display(&does_s32_impl),
                                    ::core::fmt::ArgumentV1::new_display(&does_s16_impl),
                                    ::core::fmt::ArgumentV1::new_display(&does_s8_impl),
                                    ::core::fmt::ArgumentV1::new_display(&does_u64_impl),
                                    ::core::fmt::ArgumentV1::new_display(&does_u32_impl),
                                    ::core::fmt::ArgumentV1::new_display(&does_u16_impl),
                                    ::core::fmt::ArgumentV1::new_display(&does_u8_impl),
                                ],
                            ),
                        );
                    };
                    if impltors.len() > 1 {
                        return Err(
                            TypeError::MultiplePossibleIntSpecializations {
                                int_types: impltors,
                                int_types_file_span: file_span,
                                trt: self
                                    .string_interner
                                    .resolve(&restriction.name)
                                    .to_string(),
                            }
                                .to_diagnostic(),
                        );
                    } else if impltors.is_empty() {
                        unmet_restrictions
                            .push(
                                self
                                    .tenv
                                    .fmt_trait_restriction(restriction)
                                    .file_span(restriction.name.file_id, restriction.name.span),
                            );
                    }
                }
                if !unmet_restrictions.is_empty() {
                    Err(
                        TypeError::TraitRestrictionsNotMet {
                            ty: "int".to_string(),
                            ty_file_span: file_span,
                            unmet_restrictions,
                        }
                            .to_diagnostic(),
                    )
                } else {
                    Ok(())
                }
            }
        }
    }
    mod unify {
        use super::*;
        impl TChecker {
            pub fn unify(
                &mut self,
                a: TypeId,
                b: TypeId,
                unification_span: InFile<Span>,
            ) -> Result<(), Diagnostic> {
                use TypeKind::*;
                let a_kind = self.tenv.get_typekind_with_id(a);
                let b_kind = self.tenv.get_typekind_with_id(b);
                match (&a_kind.inner.inner, &b_kind.inner.inner) {
                    (Unknown, _) => {
                        let b_entry = &self.tenv.get_entry(b).inner.inner.clone();
                        if let Some(b_params) = b_entry.get_params() {
                            let ty = Type::with_params(
                                b_kind.inner.inner,
                                b_params.iter().cloned(),
                            );
                            self.tenv.set_type(a, ty);
                        } else {
                            let ty = Type::new(b_kind.inner.inner);
                            self.tenv.set_type(a, ty);
                        }
                        Ok(())
                    }
                    (Generic(_, restrictions), _) => {
                        self.check_if_type_implements_restrictions(b, &restrictions)?;
                        Ok(())
                    }
                    (Concrete(ConcreteKind::Path(path)), Int(int_id)) => {
                        match int_id {
                            Some(int_id) => self.unify(a, *int_id, unification_span),
                            None => {
                                if self.tenv.int_paths.get(path).is_some() {
                                    let ty = Type::new(TypeKind::Int(Some(a)));
                                    self.tenv.set_type(b, ty);
                                    Ok(())
                                } else {
                                    Err(self.type_mismatch(a, b, unification_span))
                                }
                            }
                        }
                    }
                    (Int(int_id), Concrete(ConcreteKind::Path(path))) => {
                        match int_id {
                            Some(int_id) => self.unify(*int_id, a, unification_span),
                            None => {
                                if self.tenv.int_paths.get(path).is_some() {
                                    let ty = Type::new(TypeKind::Int(Some(b)));
                                    self.tenv.set_type(a, ty);
                                    Ok(())
                                } else {
                                    Err(self.type_mismatch(a, b, unification_span))
                                }
                            }
                        }
                    }
                    (Concrete(ConcreteKind::Path(path)), Float(float_id)) => {
                        match float_id {
                            Some(float_id) => self.unify(a, *float_id, unification_span),
                            None => {
                                if self.tenv.float_paths.get(path).is_some() {
                                    let ty = Type::new(TypeKind::Float(Some(a)));
                                    self.tenv.set_type(b, ty);
                                    Ok(())
                                } else {
                                    Err(self.type_mismatch(a, b, unification_span))
                                }
                            }
                        }
                    }
                    (Float(float_id), Concrete(ConcreteKind::Path(path))) => {
                        match float_id {
                            Some(float_id) => self.unify(*float_id, a, unification_span),
                            None => {
                                if self.tenv.float_paths.get(path).is_some() {
                                    let ty = Type::new(TypeKind::Float(Some(b)));
                                    self.tenv.set_type(a, ty);
                                    Ok(())
                                } else {
                                    Err(self.type_mismatch(a, b, unification_span))
                                }
                            }
                        }
                    }
                    (Concrete(concrete_a), Concrete(concrete_b)) => {
                        if concrete_a == concrete_b {
                            Ok(())
                        } else {
                            Err(self.type_mismatch(a, b, unification_span))
                        }
                    }
                    (_, _) => Err(self.type_mismatch(a, b, unification_span)),
                }
            }
            fn type_mismatch(
                &self,
                a: TypeId,
                b: TypeId,
                unification_span: InFile<Span>,
            ) -> Diagnostic {
                let a_file_span = self.tenv.get_type_filespan(a);
                let b_file_span = self.tenv.get_type_filespan(b);
                TypeError::TypeMismatch {
                    a: self.tenv.fmt_ty_id(a),
                    a_file_span,
                    b: self.tenv.fmt_ty_id(b),
                    b_file_span,
                    span: (),
                    span_file_span: unification_span,
                }
                    .to_diagnostic()
            }
        }
    }
    pub struct TChecker {
        pub tenv: TEnv,
        trait_implementation_table: TraitImplementationTable,
        string_interner: &'static ThreadedRodeo,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TChecker {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TChecker",
                "tenv",
                &&self.tenv,
                "trait_implementation_table",
                &&self.trait_implementation_table,
                "string_interner",
                &&self.string_interner,
            )
        }
    }
    impl TChecker {
        pub fn new(string_interner: &'static ThreadedRodeo) -> Self {
            Self {
                tenv: TEnv::new(string_interner),
                trait_implementation_table: TraitImplementationTable::new(),
                string_interner,
            }
        }
    }
}
pub mod diagnostics {
    use flux_diagnostics::{quote_and_listify, Plural};
    use flux_proc_macros::diagnostic;
    use flux_span::FileSpanned;
    use itertools::Itertools;
    pub enum TypeError {
        ConflictingTraitImplementations {
            trait_name: String,
            impltor: String,
            implementation_a: (),
            implementation_a_file_span: flux_span::InFile<flux_span::Span>,
            implementation_b: (),
            implementation_b_file_span: flux_span::InFile<flux_span::Span>,
        },
        TraitDoesNotExist {
            trait_name: String,
            trait_name_file_span: flux_span::InFile<flux_span::Span>,
        },
        TraitNotImplementedForType {
            restriction: String,
            restriction_file_span: flux_span::InFile<flux_span::Span>,
            type_supposed_to_implement_trait: String,
            type_supposed_to_implement_trait_file_span: flux_span::InFile<
                flux_span::Span,
            >,
        },
        TraitRestrictionsNotMet {
            ty: String,
            ty_file_span: flux_span::InFile<flux_span::Span>,
            unmet_restrictions: Vec<FileSpanned<String>>,
        },
        TypeMismatch {
            a: String,
            a_file_span: flux_span::InFile<flux_span::Span>,
            b: String,
            b_file_span: flux_span::InFile<flux_span::Span>,
            span: (),
            span_file_span: flux_span::InFile<flux_span::Span>,
        },
        UnknownFunction {
            path: String,
            path_file_span: flux_span::InFile<flux_span::Span>,
        },
        UnknownStruct {
            path: String,
            path_file_span: flux_span::InFile<flux_span::Span>,
        },
        UnknownType { path: String, path_file_span: flux_span::InFile<flux_span::Span> },
        UnknownVariable {
            name: String,
            name_file_span: flux_span::InFile<flux_span::Span>,
        },
        MultiplePossibleIntSpecializations {
            int_types: Vec<String>,
            int_types_file_span: flux_span::InFile<flux_span::Span>,
            trt: String,
        },
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TypeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TypeError::ConflictingTraitImplementations {
                    trait_name: __self_0,
                    impltor: __self_1,
                    implementation_a: __self_2,
                    implementation_a_file_span: __self_3,
                    implementation_b: __self_4,
                    implementation_b_file_span: __self_5,
                } => {
                    let names: &'static _ = &[
                        "trait_name",
                        "impltor",
                        "implementation_a",
                        "implementation_a_file_span",
                        "implementation_b",
                        "implementation_b_file_span",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &__self_0,
                        &__self_1,
                        &__self_2,
                        &__self_3,
                        &__self_4,
                        &__self_5,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "ConflictingTraitImplementations",
                        names,
                        values,
                    )
                }
                TypeError::TraitDoesNotExist {
                    trait_name: __self_0,
                    trait_name_file_span: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "TraitDoesNotExist",
                        "trait_name",
                        &__self_0,
                        "trait_name_file_span",
                        &__self_1,
                    )
                }
                TypeError::TraitNotImplementedForType {
                    restriction: __self_0,
                    restriction_file_span: __self_1,
                    type_supposed_to_implement_trait: __self_2,
                    type_supposed_to_implement_trait_file_span: __self_3,
                } => {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "TraitNotImplementedForType",
                        "restriction",
                        &__self_0,
                        "restriction_file_span",
                        &__self_1,
                        "type_supposed_to_implement_trait",
                        &__self_2,
                        "type_supposed_to_implement_trait_file_span",
                        &__self_3,
                    )
                }
                TypeError::TraitRestrictionsNotMet {
                    ty: __self_0,
                    ty_file_span: __self_1,
                    unmet_restrictions: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "TraitRestrictionsNotMet",
                        "ty",
                        &__self_0,
                        "ty_file_span",
                        &__self_1,
                        "unmet_restrictions",
                        &__self_2,
                    )
                }
                TypeError::TypeMismatch {
                    a: __self_0,
                    a_file_span: __self_1,
                    b: __self_2,
                    b_file_span: __self_3,
                    span: __self_4,
                    span_file_span: __self_5,
                } => {
                    let names: &'static _ = &[
                        "a",
                        "a_file_span",
                        "b",
                        "b_file_span",
                        "span",
                        "span_file_span",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &__self_0,
                        &__self_1,
                        &__self_2,
                        &__self_3,
                        &__self_4,
                        &__self_5,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "TypeMismatch",
                        names,
                        values,
                    )
                }
                TypeError::UnknownFunction {
                    path: __self_0,
                    path_file_span: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "UnknownFunction",
                        "path",
                        &__self_0,
                        "path_file_span",
                        &__self_1,
                    )
                }
                TypeError::UnknownStruct { path: __self_0, path_file_span: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "UnknownStruct",
                        "path",
                        &__self_0,
                        "path_file_span",
                        &__self_1,
                    )
                }
                TypeError::UnknownType { path: __self_0, path_file_span: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "UnknownType",
                        "path",
                        &__self_0,
                        "path_file_span",
                        &__self_1,
                    )
                }
                TypeError::UnknownVariable {
                    name: __self_0,
                    name_file_span: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "UnknownVariable",
                        "name",
                        &__self_0,
                        "name_file_span",
                        &__self_1,
                    )
                }
                TypeError::MultiplePossibleIntSpecializations {
                    int_types: __self_0,
                    int_types_file_span: __self_1,
                    trt: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "MultiplePossibleIntSpecializations",
                        "int_types",
                        &__self_0,
                        "int_types_file_span",
                        &__self_1,
                        "trt",
                        &__self_2,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TypeError {
        #[inline]
        fn clone(&self) -> TypeError {
            match self {
                TypeError::ConflictingTraitImplementations {
                    trait_name: __self_0,
                    impltor: __self_1,
                    implementation_a: __self_2,
                    implementation_a_file_span: __self_3,
                    implementation_b: __self_4,
                    implementation_b_file_span: __self_5,
                } => {
                    TypeError::ConflictingTraitImplementations {
                        trait_name: ::core::clone::Clone::clone(__self_0),
                        impltor: ::core::clone::Clone::clone(__self_1),
                        implementation_a: ::core::clone::Clone::clone(__self_2),
                        implementation_a_file_span: ::core::clone::Clone::clone(
                            __self_3,
                        ),
                        implementation_b: ::core::clone::Clone::clone(__self_4),
                        implementation_b_file_span: ::core::clone::Clone::clone(__self_5),
                    }
                }
                TypeError::TraitDoesNotExist {
                    trait_name: __self_0,
                    trait_name_file_span: __self_1,
                } => {
                    TypeError::TraitDoesNotExist {
                        trait_name: ::core::clone::Clone::clone(__self_0),
                        trait_name_file_span: ::core::clone::Clone::clone(__self_1),
                    }
                }
                TypeError::TraitNotImplementedForType {
                    restriction: __self_0,
                    restriction_file_span: __self_1,
                    type_supposed_to_implement_trait: __self_2,
                    type_supposed_to_implement_trait_file_span: __self_3,
                } => {
                    TypeError::TraitNotImplementedForType {
                        restriction: ::core::clone::Clone::clone(__self_0),
                        restriction_file_span: ::core::clone::Clone::clone(__self_1),
                        type_supposed_to_implement_trait: ::core::clone::Clone::clone(
                            __self_2,
                        ),
                        type_supposed_to_implement_trait_file_span: ::core::clone::Clone::clone(
                            __self_3,
                        ),
                    }
                }
                TypeError::TraitRestrictionsNotMet {
                    ty: __self_0,
                    ty_file_span: __self_1,
                    unmet_restrictions: __self_2,
                } => {
                    TypeError::TraitRestrictionsNotMet {
                        ty: ::core::clone::Clone::clone(__self_0),
                        ty_file_span: ::core::clone::Clone::clone(__self_1),
                        unmet_restrictions: ::core::clone::Clone::clone(__self_2),
                    }
                }
                TypeError::TypeMismatch {
                    a: __self_0,
                    a_file_span: __self_1,
                    b: __self_2,
                    b_file_span: __self_3,
                    span: __self_4,
                    span_file_span: __self_5,
                } => {
                    TypeError::TypeMismatch {
                        a: ::core::clone::Clone::clone(__self_0),
                        a_file_span: ::core::clone::Clone::clone(__self_1),
                        b: ::core::clone::Clone::clone(__self_2),
                        b_file_span: ::core::clone::Clone::clone(__self_3),
                        span: ::core::clone::Clone::clone(__self_4),
                        span_file_span: ::core::clone::Clone::clone(__self_5),
                    }
                }
                TypeError::UnknownFunction {
                    path: __self_0,
                    path_file_span: __self_1,
                } => {
                    TypeError::UnknownFunction {
                        path: ::core::clone::Clone::clone(__self_0),
                        path_file_span: ::core::clone::Clone::clone(__self_1),
                    }
                }
                TypeError::UnknownStruct { path: __self_0, path_file_span: __self_1 } => {
                    TypeError::UnknownStruct {
                        path: ::core::clone::Clone::clone(__self_0),
                        path_file_span: ::core::clone::Clone::clone(__self_1),
                    }
                }
                TypeError::UnknownType { path: __self_0, path_file_span: __self_1 } => {
                    TypeError::UnknownType {
                        path: ::core::clone::Clone::clone(__self_0),
                        path_file_span: ::core::clone::Clone::clone(__self_1),
                    }
                }
                TypeError::UnknownVariable {
                    name: __self_0,
                    name_file_span: __self_1,
                } => {
                    TypeError::UnknownVariable {
                        name: ::core::clone::Clone::clone(__self_0),
                        name_file_span: ::core::clone::Clone::clone(__self_1),
                    }
                }
                TypeError::MultiplePossibleIntSpecializations {
                    int_types: __self_0,
                    int_types_file_span: __self_1,
                    trt: __self_2,
                } => {
                    TypeError::MultiplePossibleIntSpecializations {
                        int_types: ::core::clone::Clone::clone(__self_0),
                        int_types_file_span: ::core::clone::Clone::clone(__self_1),
                        trt: ::core::clone::Clone::clone(__self_2),
                    }
                }
            }
        }
    }
    impl flux_diagnostics::ToDiagnostic for TypeError {
        fn to_diagnostic(&self) -> flux_diagnostics::Diagnostic {
            match self {
                #[allow(unused)]
                Self::ConflictingTraitImplementations {
                    trait_name,
                    impltor,
                    implementation_a,
                    implementation_a_file_span,
                    implementation_b,
                    implementation_b_file_span,
                } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &implementation_a_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["type `", "` implements trait `", "` here"],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(&impltor),
                                                ::core::fmt::ArgumentV1::new_display(&trait_name),
                                            ],
                                        ),
                                    );
                                    res
                                },
                            ),
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &implementation_b_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["and type `", "` also implements trait `", "` here"],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(&impltor),
                                                ::core::fmt::ArgumentV1::new_display(&trait_name),
                                            ],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(
                                &implementation_a_file_span,
                                |span| span.range.start().into(),
                            ),
                            flux_diagnostics::DiagnosticCode::ConflictingTraitImplementations,
                            "conflicting trait implementations".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::TraitDoesNotExist { trait_name, trait_name_file_span } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &trait_name_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["trait `", "` does not exist"],
                                            &[::core::fmt::ArgumentV1::new_display(&trait_name)],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&trait_name_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::TraitDoesNotExist,
                            "trait does not exist".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::TraitNotImplementedForType {
                    restriction,
                    restriction_file_span,
                    type_supposed_to_implement_trait,
                    type_supposed_to_implement_trait_file_span,
                } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &type_supposed_to_implement_trait_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["trait `", "` is not implemented for `", "`"],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(&restriction),
                                                ::core::fmt::ArgumentV1::new_display(
                                                    &type_supposed_to_implement_trait,
                                                ),
                                            ],
                                        ),
                                    );
                                    res
                                },
                            ),
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &restriction_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["trait restriction occurs here"],
                                            &[],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(
                                &type_supposed_to_implement_trait_file_span,
                                |span| span.range.start().into(),
                            ),
                            flux_diagnostics::DiagnosticCode::TraitNotImplementedForType,
                            "type does not implement trait".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::TraitRestrictionsNotMet {
                    ty,
                    ty_file_span,
                    unmet_restrictions,
                } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &ty_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["trait restriction", " ", " not met for type `", "`"],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(
                                                    &unmet_restrictions.plural("s"),
                                                ),
                                                ::core::fmt::ArgumentV1::new_display(
                                                    &quote_and_listify(
                                                        unmet_restrictions
                                                            .iter()
                                                            .map(|restriction| restriction.inner.inner.clone())
                                                            .sorted(),
                                                    ),
                                                ),
                                                ::core::fmt::ArgumentV1::new_display(&ty),
                                            ],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    unmet_restrictions
                        .iter()
                        .for_each(|label| {
                            labels.push(label);
                        });
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&ty_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::TraitRestrictionsNotMet,
                            "trait restrictions not met".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::TypeMismatch {
                    a,
                    a_file_span,
                    b,
                    b_file_span,
                    span,
                    span_file_span,
                } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &span_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["type mismatch between `", "` and `", "`"],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(&a),
                                                ::core::fmt::ArgumentV1::new_display(&b),
                                            ],
                                        ),
                                    );
                                    res
                                },
                            ),
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &a_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["`", "`"],
                                            &[::core::fmt::ArgumentV1::new_display(&a)],
                                        ),
                                    );
                                    res
                                },
                            ),
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &b_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["`", "`"],
                                            &[::core::fmt::ArgumentV1::new_display(&b)],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&span_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::TypeMismatch,
                            "type mismatch".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::UnknownFunction { path, path_file_span } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &path_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["unknown function `", "` referenced"],
                                            &[::core::fmt::ArgumentV1::new_display(&path)],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&path_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::UnknownFunction,
                            "unknown function referenced".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::UnknownStruct { path, path_file_span } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &path_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["unknown struct `", "` referenced"],
                                            &[::core::fmt::ArgumentV1::new_display(&path)],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&path_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::UnknownStruct,
                            "unknown struct referenced".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::UnknownType { path, path_file_span } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &path_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["unknown type `", "` referenced"],
                                            &[::core::fmt::ArgumentV1::new_display(&path)],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&path_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::UnknownType,
                            "unknown type referenced".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::UnknownVariable { name, name_file_span } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &name_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["unknown variable `", "` referenced"],
                                            &[::core::fmt::ArgumentV1::new_display(&name)],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&name_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::UnknownVariable,
                            "unknown variable referenced".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
                #[allow(unused)]
                Self::MultiplePossibleIntSpecializations {
                    int_types,
                    int_types_file_span,
                    trt,
                } => {
                    let mut labels = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <flux_span::InFile<
                                flux_span::Span,
                            >>::to_file_spanned(
                                &int_types_file_span,
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &[
                                                "multiple possible int specializations ",
                                                " for trait `",
                                                "`",
                                            ],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(
                                                    &quote_and_listify(int_types.iter().sorted()),
                                                ),
                                                ::core::fmt::ArgumentV1::new_display(&trt),
                                            ],
                                        ),
                                    );
                                    res
                                },
                            ),
                        ]),
                    );
                    flux_diagnostics::Diagnostic::error(
                            flux_span::InFile::map_ref::<
                                fn(&flux_span::Span) -> usize,
                                usize,
                            >(&int_types_file_span, |span| span.range.start().into()),
                            flux_diagnostics::DiagnosticCode::MultiplePossibleIntSpecializations,
                            "multiple possible int specializations".to_string(),
                            labels,
                        )
                        .opt_with_help(None)
                }
            }
        }
    }
}
mod env {
    use std::fmt::Display;
    use flux_diagnostics::{Diagnostic, ToDiagnostic};
    use flux_span::{FileSpanned, InFile, Span, Spanned};
    use itertools::Itertools;
    use lasso::{Spur, ThreadedRodeo};
    use owo_colors::OwoColorize;
    use std::collections::HashSet;
    use crate::{
        diagnostics::TypeError, r#type::{ConcreteKind, Type, TypeId, TypeKind},
        scope::Scope,
    };
    pub struct TEnv {
        pub string_interner: &'static ThreadedRodeo,
        entries: Vec<FileSpanned<TEntry>>,
        pub locals: Vec<Scope>,
        pub(super) int_paths: HashSet<Spur>,
        pub(super) float_paths: HashSet<Spur>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TEnv {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "TEnv",
                "string_interner",
                &&self.string_interner,
                "entries",
                &&self.entries,
                "locals",
                &&self.locals,
                "int_paths",
                &&self.int_paths,
                "float_paths",
                &&self.float_paths,
            )
        }
    }
    pub struct TraitRestriction {
        pub name: FileSpanned<Spur>,
        pub args: Vec<TypeId>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TraitRestriction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TraitRestriction",
                "name",
                &&self.name,
                "args",
                &&self.args,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TraitRestriction {
        #[inline]
        fn clone(&self) -> TraitRestriction {
            TraitRestriction {
                name: ::core::clone::Clone::clone(&self.name),
                args: ::core::clone::Clone::clone(&self.args),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TraitRestriction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TraitRestriction {
        #[inline]
        fn eq(&self, other: &TraitRestriction) -> bool {
            self.name == other.name && self.args == other.args
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TraitRestriction {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TraitRestriction {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<FileSpanned<Spur>>;
            let _: ::core::cmp::AssertParamIsEq<Vec<TypeId>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TraitRestriction {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.name, state);
            ::core::hash::Hash::hash(&self.args, state)
        }
    }
    impl TraitRestriction {
        pub fn new(name: FileSpanned<Spur>, args: Vec<TypeId>) -> Self {
            Self { name, args }
        }
    }
    /// A `flux_typesystem` type entry
    ///
    /// Stores the [`Key`] of the type constructor and a list of constraints
    pub struct TEntry {
        keys: Vec<TypeKind>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TEntry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "TEntry",
                "keys",
                &&self.keys,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TEntry {
        #[inline]
        fn clone(&self) -> TEntry {
            TEntry {
                keys: ::core::clone::Clone::clone(&self.keys),
            }
        }
    }
    impl TEntry {
        pub fn new(constr: TypeKind) -> Self {
            Self {
                keys: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([constr])),
            }
        }
        pub fn with_args(
            constr: TypeKind,
            args: impl Iterator<Item = TypeKind>,
        ) -> Self {
            let keys = std::iter::once(constr).chain(args).collect();
            Self { keys }
        }
        pub fn get_constr(&self) -> &TypeKind {
            &self.keys[0]
        }
        pub fn get_params(&self) -> Option<&[TypeKind]> {
            self.keys.get(1..)
        }
        pub fn set_constr(&mut self, key: TypeKind) {
            self.keys[0] = key;
        }
        pub fn set_params(&mut self, params: impl Iterator<Item = TypeKind>) {
            self.keys.splice(1.., params.collect::<Vec<_>>());
        }
    }
    impl TEnv {
        /// Construct a new `flux_typesystem` [`TEnv`]
        pub fn new(string_interner: &'static ThreadedRodeo) -> Self {
            Self {
                string_interner,
                entries: ::alloc::vec::Vec::new(),
                locals: <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([Scope::new()]),
                ),
                int_paths: HashSet::from([
                    string_interner.get_or_intern_static("u8"),
                    string_interner.get_or_intern_static("u16"),
                    string_interner.get_or_intern_static("u32"),
                    string_interner.get_or_intern_static("u64"),
                    string_interner.get_or_intern_static("s8"),
                    string_interner.get_or_intern_static("s16"),
                    string_interner.get_or_intern_static("s32"),
                    string_interner.get_or_intern_static("s64"),
                ]),
                float_paths: HashSet::from([
                    string_interner.get_or_intern_static("f32"),
                    string_interner.get_or_intern_static("f64"),
                ]),
            }
        }
        /// Get a `FileSpanned<TEntry>` given a [`TypeId`]
        ///
        /// If the entry does not exist, the [`TypeId`] is invalid, which is considered an ICE.
        pub fn get_entry(&self, id: TypeId) -> &FileSpanned<TEntry> {
            self.entries
                .get(id.get())
                .expect(
                    "internal compiler error: tried retrieving type with invalid type id",
                )
        }
        /// Get a `&mut FileSpanned<TEntry>` given a [`TypeId`]
        ///
        /// If the entry does not exist, the [`TypeId`] is invalid, which is considered an ICE.
        pub fn get_entry_mut(&mut self, id: TypeId) -> &mut FileSpanned<TEntry> {
            self.entries
                .get_mut(id.get())
                .expect(
                    "internal compiler error: tried retrieving type with invalid type id",
                )
        }
        /// Get a `Spanned<TypeKind>` given a [`TypeId`]
        ///
        /// If the [`TEntry`] for the given [`TypeId`] does not exist, the [`TypeId`] is invalid, which
        /// is considered an ICE.
        pub fn get_typekind_with_id(&self, id: TypeId) -> FileSpanned<TypeKind> {
            let entry = self.get_entry(id);
            entry.map_inner_ref(|entry| entry.get_constr().clone())
        }
        /// Get the `InFile<Span>` of a [`Type`] given its [`TypeId`]
        ///
        /// If there is no [`TEntry`] associated with the given [`TypeId`] in the [`TEnv`], the
        /// [`TypeId`] is invalid, which is considered an ICE.
        pub fn get_type_filespan(&self, id: TypeId) -> InFile<Span> {
            let entry = self.get_entry(id);
            entry.map_ref(|spanned| spanned.span)
        }
        pub fn get_call_return_type(&self, _path: &[Spur]) -> TypeId {
            ::core::panicking::panic("not yet implemented")
        }
        /// Insert a unit type `()` into the [`TEnv`]
        #[inline]
        pub fn insert_unit(&mut self, span: InFile<Span>) -> TypeId {
            let ty = Type::new(
                TypeKind::Concrete(ConcreteKind::Tuple(::alloc::vec::Vec::new())),
            );
            self.insert(FileSpanned::new(Spanned::new(ty, span.inner), span.file_id))
        }
        /// Insert an unknown type into the [`TEnv`]
        #[inline]
        pub fn insert_unknown(&mut self, span: InFile<Span>) -> TypeId {
            let ty = Type::new(TypeKind::Unknown);
            self.insert(FileSpanned::new(Spanned::new(ty, span.inner), span.file_id))
        }
        /// Insert an int type into the [`TEnv`]
        #[inline]
        pub fn insert_int(&mut self, span: InFile<Span>) -> TypeId {
            let ty = Type::new(TypeKind::Int(None));
            self.insert(FileSpanned::new(Spanned::new(ty, span.inner), span.file_id))
        }
        /// Insert a float type into the [`TEnv`]
        #[inline]
        pub fn insert_float(&mut self, span: InFile<Span>) -> TypeId {
            let ty = Type::new(TypeKind::Float(None));
            self.insert(FileSpanned::new(Spanned::new(ty, span.inner), span.file_id))
        }
        /// Insert a `Spanned<Type>` into the type environment
        ///
        /// This interns the [`TypeKind`] and pushes a new [`TEntry`] to th environment, returning
        /// a valid [`TypeId`]
        pub fn insert(&mut self, ty: FileSpanned<Type>) -> TypeId {
            let kind = ty.constr();
            let idx = self.entries.len();
            self.entries.push(ty.map_inner_ref(|_| TEntry::new(kind.clone())));
            TypeId::new(idx)
        }
        pub fn set_type(&mut self, id: TypeId, ty: Type) {
            let kind = ty.constr();
            self.get_entry_mut(id).inner.inner.set_constr(kind.clone());
            if let Some(kinds) = ty.params() {
                self.get_entry_mut(id).inner.inner.set_params(kinds.iter().cloned());
            }
        }
        /// Insert a local to the current [`Scope`]
        pub fn insert_local_to_scope(&mut self, name: Spur, id: TypeId) {
            self.locals
                .last_mut()
                .expect("internal compiler error: no active scope in type environment")
                .insert_local(name, id);
        }
        /// Get the [`TypeId`] of a path in any currently accessible [`Scope`]
        pub fn get_local_typeid(
            &mut self,
            name: FileSpanned<Spur>,
        ) -> Result<TypeId, Diagnostic> {
            self.locals
                .last()
                .expect("internal compiler error: no active scope in type environment")
                .try_get_local(&name)
                .map_or_else(
                    || {
                        Err(
                            TypeError::UnknownVariable {
                                name: self.string_interner.resolve(&name).to_string(),
                                name_file_span: name.to_filespan(),
                            }
                                .to_diagnostic(),
                        )
                    },
                    Ok,
                )
        }
        /// Format a `flux_typesystem` [`TypeId`] to a `String`
        ///
        /// Not to be confused with [`TypeId`]'s `Display` implementation which prints the `usize`
        /// representation preceded by `'`. This method retreives the [`TypeKind`] from the
        /// [`Interner`] and formats it using information stored in the [`TEnv`]. This formatting is
        /// not possible with a simple `Display` implementation as some [`TypeKind`]s store things such
        /// as [`TypeId`]s which need access to the [`TEnv`] in order to be formatted prettily.
        ///
        /// This method is good for debugging, and error messages.
        pub fn fmt_ty_id(&self, id: TypeId) -> String {
            let typekind = self.get_typekind_with_id(id);
            self.fmt_typekind(&typekind.inner.inner)
        }
        pub fn fmt_ty_id_constr(&self, id: TypeId) -> String {
            let typekind = self.get_typekind_with_id(id);
            self.fmt_typekind_constr(&typekind.inner.inner)
        }
        pub fn fmt_typekind_constr(&self, kind: &TypeKind) -> String {
            match kind {
                TypeKind::Generic(name, _) => {
                    self.string_interner.resolve(name).to_string()
                }
                TypeKind::Unknown => "unknown".to_string(),
                TypeKind::Int(_) => "int".to_string(),
                TypeKind::Float(_) => "float".to_string(),
                TypeKind::Ref(id) => self.fmt_ty_id_constr(*id),
                TypeKind::Concrete(concrete) => self.fmt_concrete_kind_constr(concrete),
            }
        }
        fn fmt_concrete_kind_constr(&self, kind: &ConcreteKind) -> String {
            match kind {
                ConcreteKind::Array(ty, n) => {
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["[", "; ", "]"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &self.fmt_ty_id_constr(*ty),
                                ),
                                ::core::fmt::ArgumentV1::new_display(&n),
                            ],
                        ),
                    );
                    res
                }
                ConcreteKind::Ptr(id) => {
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["*"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &self.fmt_ty_id_constr(*id),
                                ),
                            ],
                        ),
                    );
                    res
                }
                ConcreteKind::Path(spur) => {
                    self.string_interner.resolve(spur).to_string()
                }
                ConcreteKind::Tuple(ids) => {
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["(", ")"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &ids.iter().map(|id| self.fmt_ty_id_constr(*id)).join(", "),
                                ),
                            ],
                        ),
                    );
                    res
                }
            }
        }
        pub fn fmt_typekind(&self, kind: &TypeKind) -> String {
            match kind {
                TypeKind::Generic(name, restrictions) => {
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["", ""],
                            &match (
                                &self.string_interner.resolve(name),
                                &if restrictions.is_empty() {
                                    "".to_string()
                                } else {
                                    {
                                        let res = ::alloc::fmt::format(
                                            ::core::fmt::Arguments::new_v1(
                                                &[": "],
                                                &[
                                                    ::core::fmt::ArgumentV1::new_display(
                                                        &restrictions
                                                            .iter()
                                                            .map(|restriction| {
                                                                let res = ::alloc::fmt::format(
                                                                    ::core::fmt::Arguments::new_v1(
                                                                        &["", ""],
                                                                        &[
                                                                            ::core::fmt::ArgumentV1::new_display(
                                                                                &self.string_interner.resolve(&restriction.name),
                                                                            ),
                                                                            ::core::fmt::ArgumentV1::new_display(
                                                                                &if restriction.args.is_empty() {
                                                                                    "".to_string()
                                                                                } else {
                                                                                    restriction
                                                                                        .args
                                                                                        .iter()
                                                                                        .map(|arg| self.fmt_ty_id(*arg))
                                                                                        .join(", ")
                                                                                },
                                                                            ),
                                                                        ],
                                                                    ),
                                                                );
                                                                res
                                                            })
                                                            .join(", "),
                                                    ),
                                                ],
                                            ),
                                        );
                                        res
                                    }
                                },
                            ) {
                                args => {
                                    [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ]
                                }
                            },
                        ),
                    );
                    res
                }
                TypeKind::Unknown => "unknown".to_string(),
                TypeKind::Int(_) => "int".to_string(),
                TypeKind::Float(_) => "float".to_string(),
                TypeKind::Ref(id) => self.fmt_ty_id(*id),
                TypeKind::Concrete(concrete) => self.fmt_concrete_kind(concrete),
            }
        }
        /// Format a `flux_typesystem` [`TypeId`] to a `String`
        ///
        /// Not to be confused with the [`ConcreteKind`] `Display` implementation which will format the
        /// kind to the best of its ability without having any information about the [`TEnv`]. This
        /// method is able to format [`TypeId`]s, and therefore compound types such as pointers, and
        /// tuples, as well as types which require access to the string interner, such as paths.
        fn fmt_concrete_kind(&self, kind: &ConcreteKind) -> String {
            match kind {
                ConcreteKind::Array(ty, n) => {
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["[", "; ", "]"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&self.fmt_ty_id(*ty)),
                                ::core::fmt::ArgumentV1::new_display(&n),
                            ],
                        ),
                    );
                    res
                }
                ConcreteKind::Ptr(id) => {
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["*"],
                            &[::core::fmt::ArgumentV1::new_display(&self.fmt_ty_id(*id))],
                        ),
                    );
                    res
                }
                ConcreteKind::Path(spur) => {
                    self.string_interner.resolve(spur).to_string()
                }
                ConcreteKind::Tuple(ids) => {
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &["(", ")"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(
                                    &ids.iter().map(|id| self.fmt_ty_id(*id)).join(", "),
                                ),
                            ],
                        ),
                    );
                    res
                }
            }
        }
        fn fmt_tentry(&self, entry: &TEntry) -> String {
            {
                let res = ::alloc::fmt::format(
                    ::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &[
                            ::core::fmt::ArgumentV1::new_display(
                                &self.fmt_typekind(&entry.get_constr()),
                            ),
                            ::core::fmt::ArgumentV1::new_display(
                                &if let Some(params) = entry.get_params() {
                                    if params.is_empty() {
                                        "".to_string()
                                    } else {
                                        params
                                            .iter()
                                            .map(|param| self.fmt_typekind(param))
                                            .join(", ")
                                    }
                                } else {
                                    "".to_string()
                                },
                            ),
                        ],
                    ),
                );
                res
            }
        }
        pub fn fmt_trait_restriction(
            &self,
            trait_restriction: &TraitRestriction,
        ) -> String {
            {
                let res = ::alloc::fmt::format(
                    ::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (
                            &self
                                .string_interner
                                .resolve(&trait_restriction.name.inner.inner),
                            &if trait_restriction.args.is_empty() {
                                "".to_string()
                            } else {
                                {
                                    let res = ::alloc::fmt::format(
                                        ::core::fmt::Arguments::new_v1(
                                            &["<", ">"],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(
                                                    &trait_restriction
                                                        .args
                                                        .iter()
                                                        .map(|id| self.fmt_ty_id(*id))
                                                        .join(", "),
                                                ),
                                            ],
                                        ),
                                    );
                                    res
                                }
                            },
                        ) {
                            args => {
                                [
                                    ::core::fmt::ArgumentV1::new_display(args.0),
                                    ::core::fmt::ArgumentV1::new_display(args.1),
                                ]
                            }
                        },
                    ),
                );
                res
            }
        }
    }
    impl Display for TEnv {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(
                ::core::fmt::Arguments::new_v1(
                    &["", "\n  ", "\n"],
                    &match (
                        &"TEnv".green(),
                        &self
                            .entries
                            .iter()
                            .enumerate()
                            .format_with(
                                "\n  ",
                                |(idx, entry), f| {
                                    f(
                                        &::core::fmt::Arguments::new_v1(
                                            &["", "", " ", " Key(", ") ", " ", " "],
                                            &[
                                                ::core::fmt::ArgumentV1::new_display(&"'".blue()),
                                                ::core::fmt::ArgumentV1::new_display(&idx.blue()),
                                                ::core::fmt::ArgumentV1::new_display(&"->".purple()),
                                                ::core::fmt::ArgumentV1::new_display(&entry.get_constr()),
                                                ::core::fmt::ArgumentV1::new_display(&"->".purple()),
                                                ::core::fmt::ArgumentV1::new_display(
                                                    &self.fmt_tentry(entry),
                                                ),
                                            ],
                                        ),
                                    )
                                },
                            ),
                    ) {
                        args => {
                            [
                                ::core::fmt::ArgumentV1::new_display(args.0),
                                ::core::fmt::ArgumentV1::new_display(args.1),
                            ]
                        }
                    },
                ),
            )
        }
    }
    impl Display for TEntry {
        fn fmt(&self, _f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            ::core::panicking::panic("not yet implemented")
        }
    }
    impl Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(
                ::core::fmt::Arguments::new_v1(
                    &[""],
                    &[::core::fmt::ArgumentV1::new_debug(&self.constr())],
                ),
            )
        }
    }
    impl Display for ConcreteKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::Array(ty, n) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["[\'", "; ", "]"],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(&ty),
                                    ::core::fmt::ArgumentV1::new_display(&n),
                                ],
                            ),
                        )
                }
                Self::Path(path) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &[""],
                                &[::core::fmt::ArgumentV1::new_debug(&path)],
                            ),
                        )
                }
                Self::Ptr(ptr) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["*\'"],
                                &[::core::fmt::ArgumentV1::new_display(&ptr)],
                            ),
                        )
                }
                Self::Tuple(_) => {
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["()"], &[]))
                }
            }
        }
    }
}
mod scope {
    use lasso::Spur;
    use std::collections::HashMap;
    use crate::TypeId;
    pub struct Scope {
        locals: HashMap<Spur, TypeId>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Scope {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Scope",
                "locals",
                &&self.locals,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Scope {
        #[inline]
        fn default() -> Scope {
            Scope {
                locals: ::core::default::Default::default(),
            }
        }
    }
    impl Scope {
        pub fn new() -> Self {
            Self { locals: HashMap::new() }
        }
        pub fn insert_local(&mut self, name: Spur, ty: TypeId) {
            self.locals.insert(name, ty);
        }
        pub fn try_get_local(&self, name: &Spur) -> Option<TypeId> {
            self.locals.get(name).cloned()
        }
        pub fn get_local(&self, name: &Spur) -> TypeId {
            self.locals[name]
        }
    }
}
mod trait_solver {
    use flux_span::{InFile, Span};
    use lasso::Spur;
    use std::collections::HashMap;
    use crate::{TEnv, TypeId};
    pub(crate) struct TraitImplementation {
        /// First `TypeId` is the implementor, followed by the trait parameters, then the implementor parameters
        ids: Vec<TypeId>,
        num_trait_params: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TraitImplementation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TraitImplementation",
                "ids",
                &&self.ids,
                "num_trait_params",
                &&self.num_trait_params,
            )
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TraitImplementation {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.ids, state);
            ::core::hash::Hash::hash(&self.num_trait_params, state)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TraitImplementation {
        #[inline]
        fn clone(&self) -> TraitImplementation {
            TraitImplementation {
                ids: ::core::clone::Clone::clone(&self.ids),
                num_trait_params: ::core::clone::Clone::clone(&self.num_trait_params),
            }
        }
    }
    impl TEnv {}
    impl TraitImplementation {
        pub(crate) fn new(
            trait_params: Vec<TypeId>,
            impltor: TypeId,
            impltor_params: Vec<TypeId>,
        ) -> Self {
            let num_trait_params = trait_params.len();
            Self {
                ids: std::iter::once(impltor)
                    .chain(trait_params)
                    .chain(impltor_params)
                    .collect(),
                num_trait_params,
            }
        }
        pub fn get_impltor(&self) -> TypeId {
            unsafe { *self.ids.get_unchecked(0) }
        }
        pub fn get_trait_params(&self) -> Vec<TypeId> {
            if self.num_trait_params == 0 {
                ::alloc::vec::Vec::new()
            } else {
                unsafe { self.ids.get_unchecked(1..self.num_trait_params + 1).to_vec() }
            }
        }
        pub fn get_impltor_params(&self) -> Vec<TypeId> {
            self.ids.get(self.num_trait_params..).map(Vec::from).unwrap_or_else(Vec::new)
        }
    }
    pub(crate) struct TraitImplementationTable {
        /// A Map from the trait name to its implementors
        pub table: HashMap<Spur, Vec<TraitImplementation>>,
        pub spans: HashMap<Spur, Vec<(TraitImplementation, InFile<Span>)>>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TraitImplementationTable {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TraitImplementationTable",
                "table",
                &&self.table,
                "spans",
                &&self.spans,
            )
        }
    }
    impl TraitImplementationTable {
        pub fn new() -> Self {
            Self {
                table: HashMap::new(),
                spans: HashMap::new(),
            }
        }
        pub(crate) fn set_type_span(
            &mut self,
            trt: Spur,
            implementation: TraitImplementation,
            span: InFile<Span>,
        ) {
            self.spans.entry(trt).or_insert_with(Vec::new).push((implementation, span));
        }
    }
}
pub mod r#type {
    use std::fmt::Display;
    use flux_proc_macros::Locatable;
    use flux_span::WithSpan;
    use lasso::Spur;
    use crate::TraitRestriction;
    /// A `flux_typesystem` type
    ///
    /// Types consist of a constructor and parameters
    ///
    /// The type `Foo<i32, T, Bar>` has the constructor `Foo` and parameters `[i32, T, Bar]`
    ///
    /// Types always have a constructor, but not always parameters, as such we can store all the information in one vector rather than two to save memory.
    pub struct Type(Vec<TypeKind>);
    #[automatically_derived]
    impl ::core::fmt::Debug for Type {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Type", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Type {
        #[inline]
        fn clone(&self) -> Type {
            Type(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Type {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Type {
        #[inline]
        fn eq(&self, other: &Type) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Type {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Type {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<TypeKind>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Type {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl WithSpan for Type {}
    impl Type {
        /// Create a new [`Type`] with only a constructor
        ///
        /// Stores the constructor as the first element in the vector
        pub fn new(constr: TypeKind) -> Self {
            let types = ::alloc::vec::from_elem(constr, 1);
            Self(types)
        }
        /// Create a new [`Type`] with a constructor and parameters
        ///
        /// Stores the constructor as the first element in the vector, and fills the rest of the vector with the parameters
        pub fn with_params(
            constr: TypeKind,
            params: impl Iterator<Item = TypeKind>,
        ) -> Self {
            let types = std::iter::once(constr).chain(params).collect();
            Self(types)
        }
        /// Get a [`Type`]'s type constructor (the first element in the vector)
        pub fn constr(&self) -> &TypeKind {
            &self.0[0]
        }
        /// Get a [`Type`]'s type parameters (everything following the first element in the vector)
        pub fn params(&self) -> Option<&[TypeKind]> {
            self.0.get(1..)
        }
    }
    /// A `flux_typesystem` type id
    ///
    /// Types are stored in and organized by the type environment -- in order to refer to them, `TypeId`s are used.
    pub struct TypeId(usize);
    #[automatically_derived]
    impl ::core::fmt::Debug for TypeId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "TypeId", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for TypeId {
        #[inline]
        fn default() -> TypeId {
            TypeId(::core::default::Default::default())
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TypeId {
        #[inline]
        fn clone(&self) -> TypeId {
            let _: ::core::clone::AssertParamIsClone<usize>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TypeId {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TypeId {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TypeId {
        #[inline]
        fn eq(&self, other: &TypeId) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TypeId {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TypeId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<usize>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TypeId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TypeId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TypeId {
        #[inline]
        fn cmp(&self, other: &TypeId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TypeId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl WithSpan for TypeId {}
    impl TypeId {
        pub fn new(id: usize) -> Self {
            Self(id)
        }
        pub fn get(&self) -> usize {
            self.0
        }
    }
    impl Display for TypeId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(
                ::core::fmt::Arguments::new_v1(
                    &["\'"],
                    &[::core::fmt::ArgumentV1::new_display(&self.0)],
                ),
            )
        }
    }
    /// A `flux_typesystem` type kind
    ///
    /// Type Kinds
    /// ----------
    ///
    /// * Concrete
    ///     - Known
    /// * Int
    ///     - All that is known about the type is that it is an integer
    ///     - Optionally, the supertype of the integer can be known and stored with a [`TypeId`]
    /// * Float
    ///     - All that is known about the type is that it is an float
    ///     - Optionally, the supertype of the float can be known and stored with a [`TypeId`]
    /// * Ref
    ///     - Depends on the type of another [`TypeId`]
    /// * Generic
    ///     - Generic type
    /// * Unknown
    ///     - No information is known about this type
    pub enum TypeKind {
        Concrete(ConcreteKind),
        Int(Option<TypeId>),
        Float(Option<TypeId>),
        Ref(TypeId),
        Generic(Spur, Vec<TraitRestriction>),
        Unknown,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TypeKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TypeKind::Concrete(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Concrete",
                        &__self_0,
                    )
                }
                TypeKind::Int(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int",
                        &__self_0,
                    )
                }
                TypeKind::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                TypeKind::Ref(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ref",
                        &__self_0,
                    )
                }
                TypeKind::Generic(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "Generic",
                        &__self_0,
                        &__self_1,
                    )
                }
                TypeKind::Unknown => ::core::fmt::Formatter::write_str(f, "Unknown"),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TypeKind {
        #[inline]
        fn clone(&self) -> TypeKind {
            match self {
                TypeKind::Concrete(__self_0) => {
                    TypeKind::Concrete(::core::clone::Clone::clone(__self_0))
                }
                TypeKind::Int(__self_0) => {
                    TypeKind::Int(::core::clone::Clone::clone(__self_0))
                }
                TypeKind::Float(__self_0) => {
                    TypeKind::Float(::core::clone::Clone::clone(__self_0))
                }
                TypeKind::Ref(__self_0) => {
                    TypeKind::Ref(::core::clone::Clone::clone(__self_0))
                }
                TypeKind::Generic(__self_0, __self_1) => {
                    TypeKind::Generic(
                        ::core::clone::Clone::clone(__self_0),
                        ::core::clone::Clone::clone(__self_1),
                    )
                }
                TypeKind::Unknown => TypeKind::Unknown,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TypeKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TypeKind {
        #[inline]
        fn eq(&self, other: &TypeKind) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (TypeKind::Concrete(__self_0), TypeKind::Concrete(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (TypeKind::Int(__self_0), TypeKind::Int(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (TypeKind::Float(__self_0), TypeKind::Float(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (TypeKind::Ref(__self_0), TypeKind::Ref(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        TypeKind::Generic(__self_0, __self_1),
                        TypeKind::Generic(__arg1_0, __arg1_1),
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TypeKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TypeKind {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ConcreteKind>;
            let _: ::core::cmp::AssertParamIsEq<Option<TypeId>>;
            let _: ::core::cmp::AssertParamIsEq<Option<TypeId>>;
            let _: ::core::cmp::AssertParamIsEq<TypeId>;
            let _: ::core::cmp::AssertParamIsEq<Spur>;
            let _: ::core::cmp::AssertParamIsEq<Vec<TraitRestriction>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TypeKind {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                TypeKind::Concrete(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                TypeKind::Int(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                TypeKind::Float(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                TypeKind::Ref(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                TypeKind::Generic(__self_0, __self_1) => {
                    ::core::hash::Hash::hash(__self_0, state);
                    ::core::hash::Hash::hash(__self_1, state)
                }
                _ => {}
            }
        }
    }
    impl Display for TypeKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::Concrete(concrete) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &[""],
                                &[::core::fmt::ArgumentV1::new_display(&concrete)],
                            ),
                        )
                }
                Self::Float(_) => {
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["float"], &[]))
                }
                Self::Generic(name, _) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &[""],
                                &[::core::fmt::ArgumentV1::new_debug(&name)],
                            ),
                        )
                }
                Self::Int(_) => {
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["int"], &[]))
                }
                Self::Ref(id) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["Ref("],
                                &[::core::fmt::ArgumentV1::new_display(&id)],
                            ),
                        )
                }
                Self::Unknown => {
                    f.write_fmt(::core::fmt::Arguments::new_v1(&["unknown"], &[]))
                }
            }
        }
    }
    /// A `flux_typesystem` concrete kind
    ///
    /// The kind of [`TypeKind::Concrete`]
    pub enum ConcreteKind {
        Array(TypeId, u32),
        Ptr(TypeId),
        Path(Spur),
        Tuple(Vec<TypeId>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ConcreteKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ConcreteKind::Array(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "Array",
                        &__self_0,
                        &__self_1,
                    )
                }
                ConcreteKind::Ptr(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ptr",
                        &__self_0,
                    )
                }
                ConcreteKind::Path(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Path",
                        &__self_0,
                    )
                }
                ConcreteKind::Tuple(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Tuple",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ConcreteKind {
        #[inline]
        fn clone(&self) -> ConcreteKind {
            match self {
                ConcreteKind::Array(__self_0, __self_1) => {
                    ConcreteKind::Array(
                        ::core::clone::Clone::clone(__self_0),
                        ::core::clone::Clone::clone(__self_1),
                    )
                }
                ConcreteKind::Ptr(__self_0) => {
                    ConcreteKind::Ptr(::core::clone::Clone::clone(__self_0))
                }
                ConcreteKind::Path(__self_0) => {
                    ConcreteKind::Path(::core::clone::Clone::clone(__self_0))
                }
                ConcreteKind::Tuple(__self_0) => {
                    ConcreteKind::Tuple(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ConcreteKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ConcreteKind {
        #[inline]
        fn eq(&self, other: &ConcreteKind) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        ConcreteKind::Array(__self_0, __self_1),
                        ConcreteKind::Array(__arg1_0, __arg1_1),
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (ConcreteKind::Ptr(__self_0), ConcreteKind::Ptr(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConcreteKind::Path(__self_0), ConcreteKind::Path(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConcreteKind::Tuple(__self_0), ConcreteKind::Tuple(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ConcreteKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ConcreteKind {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TypeId>;
            let _: ::core::cmp::AssertParamIsEq<u32>;
            let _: ::core::cmp::AssertParamIsEq<Spur>;
            let _: ::core::cmp::AssertParamIsEq<Vec<TypeId>>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ConcreteKind {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConcreteKind,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            ConcreteKind::Array(__self_0, __self_1),
                            ConcreteKind::Array(__arg1_0, __arg1_1),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                __self_0,
                                __arg1_0,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg1_1)
                                }
                                cmp => cmp,
                            }
                        }
                        (ConcreteKind::Ptr(__self_0), ConcreteKind::Ptr(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (ConcreteKind::Path(__self_0), ConcreteKind::Path(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            ConcreteKind::Tuple(__self_0),
                            ConcreteKind::Tuple(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ConcreteKind {
        #[inline]
        fn cmp(&self, other: &ConcreteKind) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            ConcreteKind::Array(__self_0, __self_1),
                            ConcreteKind::Array(__arg1_0, __arg1_1),
                        ) => {
                            match ::core::cmp::Ord::cmp(__self_0, __arg1_0) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(__self_1, __arg1_1)
                                }
                                cmp => cmp,
                            }
                        }
                        (ConcreteKind::Ptr(__self_0), ConcreteKind::Ptr(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (ConcreteKind::Path(__self_0), ConcreteKind::Path(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            ConcreteKind::Tuple(__self_0),
                            ConcreteKind::Tuple(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ConcreteKind {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ConcreteKind::Array(__self_0, __self_1) => {
                    ::core::hash::Hash::hash(__self_0, state);
                    ::core::hash::Hash::hash(__self_1, state)
                }
                ConcreteKind::Ptr(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConcreteKind::Path(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConcreteKind::Tuple(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
}
pub use check::TChecker;
pub use env::{TEnv, TraitRestriction};
pub use r#type::{ConcreteKind, Type, TypeId, TypeKind};
