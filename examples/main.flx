type Maybe<T> enum {
	Some => T,
	None,
}

type Vec<T> struct {
	len u64,
	capacity u64,
	buf *T,
}

apply<T> to Vec<T> {
	pub fn new() -> Vec<T> => {
		let initial_capacity = 32; // what do people actually use for this
		Vec {
			len: 0,
			capacity: 0,
			buf: @flux.intrinsics.malloc(initial_capacity),
		}
	}

	fn delete() => {
		if self.buf != @flux.intrinsics.nullptr {
			@flux.intrinsics.free(self.buf);
		};
	}

	fn resize(u64 value) => {
		let output = @flux.intrinsics.malloc(value);
		if output == @flux.intrinsics.nullptr {
			return;
		};
		@flux.intrinsics.memcpy(output, self.buf, self.len);
		@flux.intrinsics.free(self.buf);
		self.buf = output;
		self.capacity = value;
	}

	fn push(T value) => {
		if self.len == self.capacity {
			let new_capacity = self.capacity * 2; // what do people actually use for this
			self.resize(new_capacity);
		};
		self.buf[self.len] = value;
		self.len = self.len + 1;
	}

	pub fn get(u64 idx) -> T => {
		self.buf[idx]
	}
}

trait Foo {}

trait Iterator<T>
	where T is Foo
{
	fn next() -> Maybe<T>;
}

type VecIterator<T> struct {
  vec Vec<T>,
	idx u64,
}

apply<T> Iterator<T> to VecIterator<T>
	where T is Foo
{
	fn next() -> Maybe<T> => {
		let len = self.vec.len;
		if self.idx == len {
			Maybe::None
		} else {
			self.idx = self.idx + 1;
			Maybe::Some(self.vec.get(self.idx))
		}
	}
}

trait IntoIterator<T, E>
	where E is Foo, T is Iterator<E>
{
	fn into_iter() -> T;
}

apply<T> IntoIterator<VecIterator<T>, T> to Vec<T>
	where T is Foo
{
	fn into_iter() -> VecIterator<T> => {
		VecIterator {
			vec: self,
			idx: 0,
		}
	}
}
