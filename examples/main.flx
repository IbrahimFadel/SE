mod foo;
mod bar;

fn main() {

}

/*
trait Foo<T, X> {
    type X;

    fn bar<X, Z>();
}

trait Bar {}

apply<A, B> Foo<A, B> to i32 {
    type X = f32;
}

apply<C, D> Foo<C, X> to i32 {
    type X = f32;
}

fn foo<A, B>(x A) -> A
    where A is Foo<A, B> + Bar
{
    0
}
*/

/*
mod foo;
mod bar;
mod bazz;

use foo::inside_foo;

struct Foo {
    x i4g,
    y f32,
    z pkg::Bar,
}

struct Bar {
    bar_field u64
}

enum Result<O, E> {
    Ok -> O,
    Err -> E,
}

trait SomeTrait {
    fn do_stuff();
}

apply SomeTrait to Bar {
    fn do_stuff() {
    }
}

fn main() -> i8 {
    let test = 0;
    let x i32 = 0;
    let y i8 = x;
    let x Foo = Foo {
        // x: x,
        y: 1,
        z: pkg::Bar {
            bar_field: 10.0,
        },
        test: test,
    };
    let new = inside_foo();
    let another_one i32 = new;

    let hmmm = BazzStruct {

    };
    let hmmm = bazz::BazzStruct {

    };

    let fee i8 = test;
    let fi i32 = 0;
    let fo = fee;
    let fum i32 = fo;
}

fn foo<T>() -> ([T; 3], i8**) {
    let foo = 0;
}
*/