/*
struct Spanned<T>
    where T is Clone
{
    inner T,
    span Span
}

enum Result<T, E> {
    Ok -> T,
    Err -> E,
    UB,
}

trait Foo<F, E>
    where F is Clone, E is Foo
{
    type T;

    fn to_foo();
    fn test() T;
    fn bar<X, Y>(x X) Y
        where X is Clone;
}

apply<A, B> Foo<A> to Spanned<B>
    where A is Clone, B is Food
{
    type T = i32;

    fn to_foo() {
    }
}
*/

fn main(x i32) -> i32 {
    let x = y::z;
}
